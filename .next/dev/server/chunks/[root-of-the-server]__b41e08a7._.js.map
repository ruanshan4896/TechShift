{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruanshan/Desktop/test%20kiro/tech-news/lib/db.ts"],"sourcesContent":["import { neon } from '@neondatabase/serverless';\n\nconst sql = neon(process.env.DATABASE_URL!);\n\nexport interface Article {\n  id: number;\n  title: string;\n  slug: string;\n  content: string;\n  summary: string;\n  cover_image_url: string;\n  published_at: Date;\n  created_at: Date;\n  category_id?: number;\n  view_count: number;\n}\n\nexport interface Category {\n  id: number;\n  name: string;\n  slug: string;\n  created_at: Date;\n}\n\nexport interface Tag {\n  id: number;\n  name: string;\n  slug: string;\n  created_at: Date;\n}\n\nexport interface ArticleWithCategory extends Article {\n  category_name?: string;\n  category_slug?: string;\n}\n\nexport interface ArticleWithTags extends Article {\n  tags?: Tag[];\n}\n\nexport async function createArticlesTable() {\n  await sql`\n    CREATE TABLE IF NOT EXISTS articles (\n      id SERIAL PRIMARY KEY,\n      title TEXT NOT NULL,\n      slug TEXT UNIQUE NOT NULL,\n      content TEXT NOT NULL,\n      summary TEXT NOT NULL,\n      cover_image_url TEXT NOT NULL,\n      published_at TIMESTAMP NOT NULL,\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n      category_id INTEGER,\n      view_count INTEGER DEFAULT 0\n    )\n  `;\n}\n\nexport async function createCategoriesAndTagsTables() {\n  // Categories table\n  await sql`\n    CREATE TABLE IF NOT EXISTS categories (\n      id SERIAL PRIMARY KEY,\n      name TEXT NOT NULL,\n      slug TEXT UNIQUE NOT NULL,\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    )\n  `;\n\n  // Tags table\n  await sql`\n    CREATE TABLE IF NOT EXISTS tags (\n      id SERIAL PRIMARY KEY,\n      name TEXT NOT NULL,\n      slug TEXT UNIQUE NOT NULL,\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    )\n  `;\n\n  // Article-Tag junction table\n  await sql`\n    CREATE TABLE IF NOT EXISTS article_tags (\n      article_id INTEGER REFERENCES articles(id) ON DELETE CASCADE,\n      tag_id INTEGER REFERENCES tags(id) ON DELETE CASCADE,\n      PRIMARY KEY (article_id, tag_id)\n    )\n  `;\n\n  // Add category_id and view_count columns if not exist\n  await sql`\n    DO $$ \n    BEGIN\n      IF NOT EXISTS (\n        SELECT 1 FROM information_schema.columns \n        WHERE table_name = 'articles' AND column_name = 'category_id'\n      ) THEN\n        ALTER TABLE articles ADD COLUMN category_id INTEGER;\n      END IF;\n      \n      IF NOT EXISTS (\n        SELECT 1 FROM information_schema.columns \n        WHERE table_name = 'articles' AND column_name = 'view_count'\n      ) THEN\n        ALTER TABLE articles ADD COLUMN view_count INTEGER DEFAULT 0;\n      END IF;\n    END $$;\n  `;\n\n  // Add foreign key for category if not exists\n  await sql`\n    DO $$ \n    BEGIN\n      IF NOT EXISTS (\n        SELECT 1 FROM information_schema.table_constraints \n        WHERE constraint_name = 'articles_category_id_fkey'\n      ) THEN\n        ALTER TABLE articles \n        ADD CONSTRAINT articles_category_id_fkey \n        FOREIGN KEY (category_id) REFERENCES categories(id) ON DELETE SET NULL;\n      END IF;\n    END $$;\n  `;\n}\n\nexport async function getLatestArticles(limit: number = 10): Promise<Article[]> {\n  const rows = await sql`\n    SELECT * FROM articles \n    ORDER BY published_at DESC \n    LIMIT ${limit}\n  `;\n  return rows as Article[];\n}\n\nexport async function getArticleBySlug(slug: string): Promise<Article | null> {\n  const rows = await sql`\n    SELECT * FROM articles \n    WHERE slug = ${slug}\n    LIMIT 1\n  `;\n  return (rows[0] as Article) || null;\n}\n\nexport async function insertArticle(article: Omit<Article, 'id' | 'created_at'>) {\n  const publishedAt = article.published_at.toISOString();\n  await sql`\n    INSERT INTO articles (title, slug, content, summary, cover_image_url, published_at)\n    VALUES (${article.title}, ${article.slug}, ${article.content}, ${article.summary}, ${article.cover_image_url}, ${publishedAt})\n  `;\n}\n\n// RSS Source Management\nexport interface RssSource {\n  id: number;\n  name: string;\n  rss_url: string;\n  is_active: boolean;\n  created_at: Date;\n}\n\nexport interface RawArticle {\n  id: number;\n  source_id: number;\n  title: string;\n  original_url: string;\n  original_content: string;\n  publication_date: Date;\n  status: 'pending' | 'processed' | 'failed';\n  created_at: Date;\n}\n\nexport async function createRssTables() {\n  await sql`\n    CREATE TABLE IF NOT EXISTS rss_sources (\n      id SERIAL PRIMARY KEY,\n      name TEXT NOT NULL,\n      rss_url TEXT UNIQUE NOT NULL,\n      is_active BOOLEAN DEFAULT true,\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    )\n  `;\n\n  await sql`\n    CREATE TABLE IF NOT EXISTS raw_articles (\n      id SERIAL PRIMARY KEY,\n      source_id INTEGER REFERENCES rss_sources(id) ON DELETE CASCADE,\n      title TEXT NOT NULL,\n      original_url TEXT UNIQUE NOT NULL,\n      original_content TEXT NOT NULL,\n      publication_date TIMESTAMP NOT NULL,\n      status TEXT CHECK (status IN ('pending', 'processed', 'failed')) DEFAULT 'pending',\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    )\n  `;\n\n  await sql`\n    CREATE INDEX IF NOT EXISTS idx_raw_articles_status ON raw_articles(status)\n  `;\n\n  await sql`\n    CREATE INDEX IF NOT EXISTS idx_raw_articles_source ON raw_articles(source_id)\n  `;\n}\n\nexport async function getActiveRssSources(): Promise<RssSource[]> {\n  const rows = await sql`\n    SELECT * FROM rss_sources \n    WHERE is_active = true\n    ORDER BY name\n  `;\n  return rows as RssSource[];\n}\n\nexport async function getAllRssSources(): Promise<RssSource[]> {\n  const rows = await sql`\n    SELECT * FROM rss_sources \n    ORDER BY name\n  `;\n  return rows as RssSource[];\n}\n\nexport async function insertRssSource(source: Omit<RssSource, 'id' | 'created_at'>) {\n  await sql`\n    INSERT INTO rss_sources (name, rss_url, is_active)\n    VALUES (${source.name}, ${source.rss_url}, ${source.is_active})\n  `;\n}\n\nexport async function updateRssSource(id: number, source: Partial<Omit<RssSource, 'id' | 'created_at'>>) {\n  const updates: string[] = [];\n  const values: any[] = [];\n  \n  if (source.name !== undefined) {\n    updates.push(`name = $${updates.length + 1}`);\n    values.push(source.name);\n  }\n  if (source.rss_url !== undefined) {\n    updates.push(`rss_url = $${updates.length + 1}`);\n    values.push(source.rss_url);\n  }\n  if (source.is_active !== undefined) {\n    updates.push(`is_active = $${updates.length + 1}`);\n    values.push(source.is_active);\n  }\n\n  if (updates.length > 0) {\n    await sql.query(`UPDATE rss_sources SET ${updates.join(', ')} WHERE id = $${updates.length + 1}`, [...values, id]);\n  }\n}\n\nexport async function deleteRssSource(id: number) {\n  await sql`DELETE FROM rss_sources WHERE id = ${id}`;\n}\n\nexport async function checkArticleExists(originalUrl: string): Promise<boolean> {\n  const rows = await sql`\n    SELECT id FROM raw_articles WHERE original_url = ${originalUrl} LIMIT 1\n  `;\n  return rows.length > 0;\n}\n\nexport async function insertRawArticle(article: Omit<RawArticle, 'id' | 'created_at'>) {\n  const publicationDate = article.publication_date.toISOString();\n  await sql`\n    INSERT INTO raw_articles (source_id, title, original_url, original_content, publication_date, status)\n    VALUES (${article.source_id}, ${article.title}, ${article.original_url}, ${article.original_content}, ${publicationDate}, ${article.status})\n  `;\n}\n\nexport async function getPendingRawArticles(limit: number = 10): Promise<RawArticle[]> {\n  const rows = await sql`\n    SELECT * FROM raw_articles \n    WHERE status = 'pending'\n    ORDER BY publication_date DESC\n    LIMIT ${limit}\n  `;\n  return rows as RawArticle[];\n}\n\nexport async function updateRawArticleStatus(id: number, status: 'pending' | 'processed' | 'failed', error?: string) {\n  if (error) {\n    await sql`\n      UPDATE raw_articles \n      SET status = ${status}\n      WHERE id = ${id}\n    `;\n  } else {\n    await sql`\n      UPDATE raw_articles \n      SET status = ${status}\n      WHERE id = ${id}\n    `;\n  }\n}\n\nexport async function checkSlugExists(slug: string): Promise<boolean> {\n  const rows = await sql`\n    SELECT id FROM articles WHERE slug = ${slug} LIMIT 1\n  `;\n  return rows.length > 0;\n}\n\nexport async function insertArticleFromRaw(article: {\n  title: string;\n  slug: string;\n  content: string;\n  summary: string;\n  cover_image_url: string;\n  published_at: Date;\n}): Promise<void> {\n  const publishedAt = article.published_at.toISOString();\n  await sql`\n    INSERT INTO articles (title, slug, content, summary, cover_image_url, published_at)\n    VALUES (${article.title}, ${article.slug}, ${article.content}, ${article.summary}, ${article.cover_image_url}, ${publishedAt})\n  `;\n}\n\nexport async function findRelatedArticles(keyword: string, excludeSlug: string, limit: number = 2): Promise<Article[]> {\n  const rows = await sql`\n    SELECT * FROM articles \n    WHERE slug != ${excludeSlug}\n    AND (\n      title ILIKE ${`%${keyword}%`}\n      OR content ILIKE ${`%${keyword}%`}\n    )\n    ORDER BY created_at DESC\n    LIMIT ${limit}\n  `;\n  return rows as Article[];\n}\n\nexport async function updateArticleContent(slug: string, content: string): Promise<void> {\n  await sql`\n    UPDATE articles \n    SET content = ${content}\n    WHERE slug = ${slug}\n  `;\n}\n\n// Categories\nexport async function getAllCategories(): Promise<Category[]> {\n  const rows = await sql`SELECT * FROM categories ORDER BY name`;\n  return rows as Category[];\n}\n\nexport async function getCategoryBySlug(slug: string): Promise<Category | null> {\n  const rows = await sql`SELECT * FROM categories WHERE slug = ${slug} LIMIT 1`;\n  return (rows[0] as Category) || null;\n}\n\nexport async function insertCategory(name: string, slug: string): Promise<void> {\n  await sql`INSERT INTO categories (name, slug) VALUES (${name}, ${slug})`;\n}\n\n// Tags\nexport async function getAllTags(): Promise<Tag[]> {\n  const rows = await sql`SELECT * FROM tags ORDER BY name`;\n  return rows as Tag[];\n}\n\nexport async function getPopularTags(limit: number = 10): Promise<Tag[]> {\n  const rows = await sql`\n    SELECT t.*, COUNT(at.article_id) as article_count\n    FROM tags t\n    LEFT JOIN article_tags at ON t.id = at.tag_id\n    GROUP BY t.id\n    ORDER BY article_count DESC, t.name\n    LIMIT ${limit}\n  `;\n  return rows as Tag[];\n}\n\nexport async function getTagBySlug(slug: string): Promise<Tag | null> {\n  const rows = await sql`SELECT * FROM tags WHERE slug = ${slug} LIMIT 1`;\n  return (rows[0] as Tag) || null;\n}\n\nexport async function findOrCreateTag(name: string, slug: string): Promise<number> {\n  const existing = await sql`SELECT id FROM tags WHERE slug = ${slug} LIMIT 1`;\n  if (existing.length > 0) {\n    return existing[0].id as number;\n  }\n  const result = await sql`INSERT INTO tags (name, slug) VALUES (${name}, ${slug}) RETURNING id`;\n  return result[0].id as number;\n}\n\nexport async function getArticlesByCategory(categorySlug: string, limit: number = 20): Promise<ArticleWithCategory[]> {\n  const rows = await sql`\n    SELECT a.*, c.name as category_name, c.slug as category_slug\n    FROM articles a\n    LEFT JOIN categories c ON a.category_id = c.id\n    WHERE c.slug = ${categorySlug}\n    ORDER BY a.published_at DESC\n    LIMIT ${limit}\n  `;\n  return rows as ArticleWithCategory[];\n}\n\nexport async function getArticlesByTag(tagSlug: string, limit: number = 20): Promise<Article[]> {\n  const rows = await sql`\n    SELECT a.*\n    FROM articles a\n    INNER JOIN article_tags at ON a.id = at.article_id\n    INNER JOIN tags t ON at.tag_id = t.id\n    WHERE t.slug = ${tagSlug}\n    ORDER BY a.published_at DESC\n    LIMIT ${limit}\n  `;\n  return rows as Article[];\n}\n\nexport async function getArticleTags(articleId: number): Promise<Tag[]> {\n  const rows = await sql`\n    SELECT t.*\n    FROM tags t\n    INNER JOIN article_tags at ON t.id = at.tag_id\n    WHERE at.article_id = ${articleId}\n    ORDER BY t.name\n  `;\n  return rows as Tag[];\n}\n\nexport async function linkArticleToTags(articleId: number, tagIds: number[]): Promise<void> {\n  for (const tagId of tagIds) {\n    await sql`\n      INSERT INTO article_tags (article_id, tag_id)\n      VALUES (${articleId}, ${tagId})\n      ON CONFLICT DO NOTHING\n    `;\n  }\n}\n\nexport async function searchArticles(query: string, limit: number = 20): Promise<Article[]> {\n  const searchTerm = `%${query}%`;\n  const rows = await sql`\n    SELECT * FROM articles\n    WHERE title ILIKE ${searchTerm} OR content ILIKE ${searchTerm}\n    ORDER BY published_at DESC\n    LIMIT ${limit}\n  `;\n  return rows as Article[];\n}\n\nexport async function incrementViewCount(slug: string): Promise<void> {\n  await sql`\n    UPDATE articles \n    SET view_count = view_count + 1\n    WHERE slug = ${slug}\n  `;\n}\n\nexport async function getFeaturedArticles(limit: number = 5): Promise<Article[]> {\n  const rows = await sql`\n    SELECT * FROM articles\n    ORDER BY view_count DESC, published_at DESC\n    LIMIT ${limit}\n  `;\n  return rows as Article[];\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 471, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruanshan/Desktop/test%20kiro/tech-news/lib/gemini.ts"],"sourcesContent":["import { GoogleGenerativeAI } from '@google/generative-ai';\n\nconst genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY!);\n\nexport interface ProcessedArticle {\n  content: string;\n  summary: string;\n  suggestedTitles: string[];\n}\n\nexport async function processArticleWithGemini(\n  originalTitle: string,\n  originalContent: string,\n  originalUrl: string\n): Promise<ProcessedArticle> {\n  // Use Gemini 2.5 Flash - latest free model\n  const model = genAI.getGenerativeModel({ model: 'gemini-2.5-flash' });\n\n  // Prompt A: Tạo bài viết tổng hợp\n  const promptA = `Dựa trên nội dung từ bài viết gốc tại ${originalUrl} với tiêu đề \"${originalTitle}\", hãy viết một bài viết mới, đầy đủ và chi tiết về chủ đề này.\n\nNội dung gốc:\n${originalContent}\n\n**Yêu cầu:**\n- Viết bài viết hoàn chỉnh bằng tiếng Việt\n- Bổ sung thêm các thông tin nền\n- Giải thích các thuật ngữ kỹ thuật cho người mới\n- Đưa ra góc nhìn so sánh với các công nghệ/sản phẩm tương tự (nếu có)\n- Giữ văn phong chuyên nghiệp nhưng dễ tiếp cận\n- Không sao chép nguyên văn\n- Độ dài: 500-800 từ\n- Format: Markdown với heading (##), bullet points, và đoạn văn rõ ràng\n\nHãy viết bài viết:`;\n\n  const resultA = await model.generateContent(promptA);\n  const content = resultA.response.text();\n\n  // Prompt B: Tạo tóm tắt và tiêu đề\n  const promptB = `Từ nội dung bài viết sau:\n\n${content}\n\nHãy:\n1. Viết một đoạn tóm tắt (meta description) trong khoảng 150-155 ký tự, hấp dẫn và chuẩn SEO\n2. Đề xuất 3 tiêu đề mới hấp dẫn, chuẩn SEO (dưới 60 ký tự mỗi tiêu đề)\n\nFormat trả về:\nSUMMARY: [tóm tắt ở đây]\nTITLE1: [tiêu đề 1]\nTITLE2: [tiêu đề 2]\nTITLE3: [tiêu đề 3]`;\n\n  const resultB = await model.generateContent(promptB);\n  const metaText = resultB.response.text();\n\n  // Parse kết quả\n  const summaryMatch = metaText.match(/SUMMARY:\\s*(.+)/);\n  const title1Match = metaText.match(/TITLE1:\\s*(.+)/);\n  const title2Match = metaText.match(/TITLE2:\\s*(.+)/);\n  const title3Match = metaText.match(/TITLE3:\\s*(.+)/);\n\n  const summary = summaryMatch ? summaryMatch[1].trim() : originalTitle.substring(0, 155);\n  const suggestedTitles = [\n    title1Match ? title1Match[1].trim() : originalTitle,\n    title2Match ? title2Match[1].trim() : originalTitle,\n    title3Match ? title3Match[1].trim() : originalTitle,\n  ];\n\n  return {\n    content,\n    summary,\n    suggestedTitles,\n  };\n}\n\nexport function generateSlug(title: string): string {\n  return title\n    .toLowerCase()\n    .normalize('NFD')\n    .replace(/[\\u0300-\\u036f]/g, '') // Remove diacritics\n    .replace(/đ/g, 'd')\n    .replace(/[^a-z0-9\\s-]/g, '')\n    .trim()\n    .replace(/\\s+/g, '-')\n    .replace(/-+/g, '-')\n    .substring(0, 100);\n}\n\nexport function getDefaultCoverImage(title: string): string {\n  // Sử dụng Unsplash với keyword từ title\n  const keywords = title.split(' ').slice(0, 3).join(',');\n  return `https://images.unsplash.com/photo-1677442136019-21780ecad995?w=800&q=80`;\n}\n\nexport async function extractKeywords(content: string, title: string): Promise<string[]> {\n  const model = genAI.getGenerativeModel({ model: 'gemini-2.5-flash' });\n\n  const prompt = `Từ bài viết sau với tiêu đề \"${title}\":\n\n${content.substring(0, 1000)}\n\nHãy trích xuất 5-7 từ khóa hoặc thực thể quan trọng nhất (tên công nghệ, sản phẩm, công ty, khái niệm kỹ thuật).\n\nYêu cầu:\n- Chỉ trả về danh sách từ khóa, mỗi từ khóa trên một dòng\n- Không giải thích, không đánh số\n- Từ khóa nên là cụm từ ngắn (1-3 từ)\n- Ưu tiên các từ khóa xuất hiện nhiều lần trong bài\n\nVí dụ format:\niPhone 17\nAI\nOpenAI\nchip xử lý\nmachine learning`;\n\n  const result = await model.generateContent(prompt);\n  const text = result.response.text();\n  \n  // Parse keywords từ response\n  const keywords = text\n    .split('\\n')\n    .map(line => line.trim())\n    .filter(line => line.length > 0 && !line.match(/^\\d+\\./)) // Remove numbered lines\n    .slice(0, 7); // Max 7 keywords\n\n  return keywords;\n}\n"],"names":[],"mappings":";;;;;;;;;;AAAA;;AAEA,MAAM,QAAQ,IAAI,sLAAkB,CAAC,QAAQ,GAAG,CAAC,cAAc;AAQxD,eAAe,yBACpB,aAAqB,EACrB,eAAuB,EACvB,WAAmB;IAEnB,2CAA2C;IAC3C,MAAM,QAAQ,MAAM,kBAAkB,CAAC;QAAE,OAAO;IAAmB;IAEnE,kCAAkC;IAClC,MAAM,UAAU,CAAC,sCAAsC,EAAE,YAAY,cAAc,EAAE,cAAc;;;AAGrG,EAAE,gBAAgB;;;;;;;;;;;;kBAYA,CAAC;IAEjB,MAAM,UAAU,MAAM,MAAM,eAAe,CAAC;IAC5C,MAAM,UAAU,QAAQ,QAAQ,CAAC,IAAI;IAErC,mCAAmC;IACnC,MAAM,UAAU,CAAC;;AAEnB,EAAE,QAAQ;;;;;;;;;;mBAUS,CAAC;IAElB,MAAM,UAAU,MAAM,MAAM,eAAe,CAAC;IAC5C,MAAM,WAAW,QAAQ,QAAQ,CAAC,IAAI;IAEtC,gBAAgB;IAChB,MAAM,eAAe,SAAS,KAAK,CAAC;IACpC,MAAM,cAAc,SAAS,KAAK,CAAC;IACnC,MAAM,cAAc,SAAS,KAAK,CAAC;IACnC,MAAM,cAAc,SAAS,KAAK,CAAC;IAEnC,MAAM,UAAU,eAAe,YAAY,CAAC,EAAE,CAAC,IAAI,KAAK,cAAc,SAAS,CAAC,GAAG;IACnF,MAAM,kBAAkB;QACtB,cAAc,WAAW,CAAC,EAAE,CAAC,IAAI,KAAK;QACtC,cAAc,WAAW,CAAC,EAAE,CAAC,IAAI,KAAK;QACtC,cAAc,WAAW,CAAC,EAAE,CAAC,IAAI,KAAK;KACvC;IAED,OAAO;QACL;QACA;QACA;IACF;AACF;AAEO,SAAS,aAAa,KAAa;IACxC,OAAO,MACJ,WAAW,GACX,SAAS,CAAC,OACV,OAAO,CAAC,oBAAoB,IAAI,oBAAoB;KACpD,OAAO,CAAC,MAAM,KACd,OAAO,CAAC,iBAAiB,IACzB,IAAI,GACJ,OAAO,CAAC,QAAQ,KAChB,OAAO,CAAC,OAAO,KACf,SAAS,CAAC,GAAG;AAClB;AAEO,SAAS,qBAAqB,KAAa;IAChD,wCAAwC;IACxC,MAAM,WAAW,MAAM,KAAK,CAAC,KAAK,KAAK,CAAC,GAAG,GAAG,IAAI,CAAC;IACnD,OAAO,CAAC,uEAAuE,CAAC;AAClF;AAEO,eAAe,gBAAgB,OAAe,EAAE,KAAa;IAClE,MAAM,QAAQ,MAAM,kBAAkB,CAAC;QAAE,OAAO;IAAmB;IAEnE,MAAM,SAAS,CAAC,6BAA6B,EAAE,MAAM;;AAEvD,EAAE,QAAQ,SAAS,CAAC,GAAG,MAAM;;;;;;;;;;;;;;;gBAeb,CAAC;IAEf,MAAM,SAAS,MAAM,MAAM,eAAe,CAAC;IAC3C,MAAM,OAAO,OAAO,QAAQ,CAAC,IAAI;IAEjC,6BAA6B;IAC7B,MAAM,WAAW,KACd,KAAK,CAAC,MACN,GAAG,CAAC,CAAA,OAAQ,KAAK,IAAI,IACrB,MAAM,CAAC,CAAA,OAAQ,KAAK,MAAM,GAAG,KAAK,CAAC,KAAK,KAAK,CAAC,WAAW,wBAAwB;KACjF,KAAK,CAAC,GAAG,IAAI,iBAAiB;IAEjC,OAAO;AACT"}},
    {"offset": {"line": 583, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruanshan/Desktop/test%20kiro/tech-news/lib/internal-linking.ts"],"sourcesContent":["import { findRelatedArticles } from './db';\n\ninterface InternalLink {\n  keyword: string;\n  url: string;\n  title: string;\n}\n\nexport async function buildInternalLinks(\n  content: string,\n  keywords: string[],\n  currentSlug: string,\n  maxLinks: number = 4\n): Promise<string> {\n  const links: InternalLink[] = [];\n\n  // Tìm bài viết liên quan cho mỗi keyword\n  for (const keyword of keywords) {\n    if (links.length >= maxLinks) break;\n\n    const relatedArticles = await findRelatedArticles(keyword, currentSlug, 1);\n    \n    if (relatedArticles.length > 0) {\n      const article = relatedArticles[0];\n      links.push({\n        keyword,\n        url: `/posts/${article.slug}`,\n        title: article.title,\n      });\n    }\n  }\n\n  // Chèn links vào content\n  let updatedContent = content;\n  const insertedKeywords = new Set<string>();\n\n  for (const link of links) {\n    // Tìm lần xuất hiện đầu tiên của keyword (case-insensitive)\n    const regex = new RegExp(`\\\\b${escapeRegex(link.keyword)}\\\\b`, 'i');\n    const match = updatedContent.match(regex);\n\n    if (match && !insertedKeywords.has(link.keyword.toLowerCase())) {\n      // Thay thế lần xuất hiện đầu tiên bằng link\n      updatedContent = updatedContent.replace(\n        regex,\n        `<a href=\"${link.url}\" title=\"${link.title}\" class=\"internal-link\">${match[0]}</a>`\n      );\n      insertedKeywords.add(link.keyword.toLowerCase());\n    }\n  }\n\n  return updatedContent;\n}\n\nfunction escapeRegex(str: string): string {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\nexport function countInternalLinks(content: string): number {\n  const matches = content.match(/<a[^>]*class=\"internal-link\"[^>]*>/g);\n  return matches ? matches.length : 0;\n}\n"],"names":[],"mappings":";;;;;;AAAA;;AAQO,eAAe,mBACpB,OAAe,EACf,QAAkB,EAClB,WAAmB,EACnB,WAAmB,CAAC;IAEpB,MAAM,QAAwB,EAAE;IAEhC,yCAAyC;IACzC,KAAK,MAAM,WAAW,SAAU;QAC9B,IAAI,MAAM,MAAM,IAAI,UAAU;QAE9B,MAAM,kBAAkB,MAAM,IAAA,kIAAmB,EAAC,SAAS,aAAa;QAExE,IAAI,gBAAgB,MAAM,GAAG,GAAG;YAC9B,MAAM,UAAU,eAAe,CAAC,EAAE;YAClC,MAAM,IAAI,CAAC;gBACT;gBACA,KAAK,CAAC,OAAO,EAAE,QAAQ,IAAI,EAAE;gBAC7B,OAAO,QAAQ,KAAK;YACtB;QACF;IACF;IAEA,yBAAyB;IACzB,IAAI,iBAAiB;IACrB,MAAM,mBAAmB,IAAI;IAE7B,KAAK,MAAM,QAAQ,MAAO;QACxB,4DAA4D;QAC5D,MAAM,QAAQ,IAAI,OAAO,CAAC,GAAG,EAAE,YAAY,KAAK,OAAO,EAAE,GAAG,CAAC,EAAE;QAC/D,MAAM,QAAQ,eAAe,KAAK,CAAC;QAEnC,IAAI,SAAS,CAAC,iBAAiB,GAAG,CAAC,KAAK,OAAO,CAAC,WAAW,KAAK;YAC9D,4CAA4C;YAC5C,iBAAiB,eAAe,OAAO,CACrC,OACA,CAAC,SAAS,EAAE,KAAK,GAAG,CAAC,SAAS,EAAE,KAAK,KAAK,CAAC,wBAAwB,EAAE,KAAK,CAAC,EAAE,CAAC,IAAI,CAAC;YAErF,iBAAiB,GAAG,CAAC,KAAK,OAAO,CAAC,WAAW;QAC/C;IACF;IAEA,OAAO;AACT;AAEA,SAAS,YAAY,GAAW;IAC9B,OAAO,IAAI,OAAO,CAAC,uBAAuB;AAC5C;AAEO,SAAS,mBAAmB,OAAe;IAChD,MAAM,UAAU,QAAQ,KAAK,CAAC;IAC9B,OAAO,UAAU,QAAQ,MAAM,GAAG;AACpC"}},
    {"offset": {"line": 632, "column": 0}, "map": {"version":3,"sources":["file:///Users/ruanshan/Desktop/test%20kiro/tech-news/app/api/process-articles/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\nimport {\n  getPendingRawArticles,\n  updateRawArticleStatus,\n  insertArticleFromRaw,\n  checkSlugExists,\n  updateArticleContent,\n} from '@/lib/db';\nimport { processArticleWithGemini, generateSlug, getDefaultCoverImage, extractKeywords } from '@/lib/gemini';\nimport { buildInternalLinks, countInternalLinks } from '@/lib/internal-linking';\n\nexport async function GET(request: Request) {\n  try {\n    // Verify cron secret for security\n    const authHeader = request.headers.get('authorization');\n    if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n    }\n\n    // Check if Gemini API key is configured\n    if (!process.env.GEMINI_API_KEY) {\n      return NextResponse.json(\n        { error: 'Gemini API key not configured' },\n        { status: 500 }\n      );\n    }\n\n    const pendingArticles = await getPendingRawArticles(5);\n    const results = [];\n\n    for (const rawArticle of pendingArticles) {\n      try {\n        console.log(`Processing article: ${rawArticle.title}`);\n\n        // Process with Gemini\n        const processed = await processArticleWithGemini(\n          rawArticle.title,\n          rawArticle.original_content,\n          rawArticle.original_url\n        );\n\n        // Choose best title (first suggestion)\n        const finalTitle = processed.suggestedTitles[0];\n        let slug = generateSlug(finalTitle);\n\n        // Ensure unique slug\n        let slugCounter = 1;\n        while (await checkSlugExists(slug)) {\n          slug = `${generateSlug(finalTitle)}-${slugCounter}`;\n          slugCounter++;\n        }\n\n        // Get cover image\n        const coverImage = getDefaultCoverImage(finalTitle);\n\n        // Insert into articles table (without internal links first)\n        await insertArticleFromRaw({\n          title: finalTitle,\n          slug,\n          content: processed.content,\n          summary: processed.summary,\n          cover_image_url: coverImage,\n          published_at: rawArticle.publication_date,\n        });\n\n        console.log(`✓ Article inserted: ${finalTitle}`);\n\n        // Extract keywords for internal linking\n        console.log('  Extracting keywords...');\n        const keywords = await extractKeywords(processed.content, finalTitle);\n        console.log(`  Keywords: ${keywords.join(', ')}`);\n\n        // Build internal links\n        console.log('  Building internal links...');\n        const contentWithLinks = await buildInternalLinks(\n          processed.content,\n          keywords,\n          slug,\n          4 // Max 4 internal links\n        );\n\n        const linkCount = countInternalLinks(contentWithLinks);\n        console.log(`  Added ${linkCount} internal links`);\n\n        // Update article with internal links\n        if (linkCount > 0) {\n          await updateArticleContent(slug, contentWithLinks);\n        }\n\n        // Update raw article status\n        await updateRawArticleStatus(rawArticle.id, 'processed');\n\n        results.push({\n          id: rawArticle.id,\n          originalTitle: rawArticle.title,\n          newTitle: finalTitle,\n          slug,\n          internalLinks: linkCount,\n          keywords: keywords.slice(0, 3), // Show first 3 keywords\n          status: 'success',\n        });\n\n        console.log(`✓ Processed: ${finalTitle} (${linkCount} links)`);\n      } catch (error) {\n        console.error(`Error processing article ${rawArticle.id}:`, error);\n\n        // Update status to failed\n        await updateRawArticleStatus(\n          rawArticle.id,\n          'failed',\n          error instanceof Error ? error.message : 'Unknown error'\n        );\n\n        results.push({\n          id: rawArticle.id,\n          originalTitle: rawArticle.title,\n          status: 'failed',\n          error: error instanceof Error ? error.message : 'Unknown error',\n        });\n      }\n    }\n\n    return NextResponse.json({\n      success: true,\n      processed: results.length,\n      results,\n      timestamp: new Date().toISOString(),\n    });\n  } catch (error) {\n    console.error('Error in process-articles:', error);\n    return NextResponse.json(\n      {\n        error: 'Internal server error',\n        details: error instanceof Error ? error.message : 'Unknown error',\n      },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":"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"}}]
}